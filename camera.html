<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<script type="text/javascript" src="js/mobile-check.js"></script>
	<script type="text/javascript" src="js/device-check.js"></script>
	<script type="text/javascript" src="js/Blob.js"></script>
	<script type="text/javascript" src="js/FileSaver.min.js"></script>
    <style type="text/css">
		#container {
			background:black;
			padding-top: 60px;
		}
		#desktop-capture {
			width: 40%;
			margin: 0 auto;
		}
		#desktop-capture img { width: 100%; }
		#home { background-color: black; }
    </style>
    <title>chimera</title>
    <script type="text/javascript" charset="utf-8">
        	

          var pictureSource;   // picture source
          var destinationType; // sets the format of returned value

          document.addEventListener("deviceready",onDeviceReady,false);

          function onDeviceReady() {
              console.log('device ready')
              pictureSource=navigator.camera.PictureSourceType;
              destinationType=navigator.camera.DestinationType;
          }
        
          // get canvas and save as image (uses  plugin)
          function capCanvas() {    
            window.canvas2ImagePlugin.saveImageDataToLibrary(
                 function(msg){
                  console.log(msg);
                 },
                 function(err){
                     console.log(err);
                 },
                 document.getElementById('myCanvas')
             );
           }

           //when image data is received, add img to the canvas, choose random skeleton image, add that, then save both as image
           function onPhotoDataSuccess(imageData) { 
             canvasImg("data:image/png;base64," + imageData); 
             var sk = getRand(skels.length);
             setTimeout(function(){canvasImg(skels[sk]);}, 80); 
           }       
           // function to add images to the canvas using url (works with data)
          function canvasImg(url) {
            var c = document.getElementById("myCanvas");
            var ctx = c.getContext("2d");
            ctx.webkitImageSmoothingEnabled = true;
            var imageObj = new Image();
            imageObj.onload = function() {
              ctx.drawImage(imageObj, parseInt(0), parseInt(0), 320, 320);
            };
            imageObj.src = url;
            setTimeout(function(){capCanvas();}, 500);
          }

        
          function capturePhotoEdit() {
            // Take picture using device camera, allow edit, and retrieve image as base64-encoded string
            navigator.camera.getPicture(onPhotoDataSuccess, onFail, { quality: 50, allowEdit: true,
              destinationType: destinationType.DATA_URL });
          }
	</script>
</head>

<body >
	<div id="container">
		<video id="webcam" autoplay style='display:none;'></video>
		<canvas id="photo"></canvas>
		<input id="mobile-capture" type="file" accept="image/*" capture="camera" />
		<div id="desktop-capture">
			<img src="/img/camera/capture.png" alt="">
		</div>
	</div>
	<div id="home"></div>
	<script>
		// list of images to superimpose on camera shots (skeletons)
		var skels = [ "img/camera/s1.png", "img/camera/s2.png", "img/camera/s3.png", "img/camera/s4.png", "img/camera/s5.png", "img/camera/s6.png", "img/camera/s7.png", "img/camera/s8.png", "img/camera/s9.png", "img/camera/s10.png" ];
		function init() {
			localStorage["appCount"]++;
			function goHome() {
				location.href = '/home.html';
			}
			const homeBtn = document.getElementById('home');
			homeBtn.addEventListener('click', goHome);
			homeBtn.addEventListener('tap', goHome);

			const cont = document.getElementById('container');
			const canvas = document.getElementById('photo');
			const context = canvas.getContext('2d');
			const webcam = document.getElementById('webcam');
			const desktopCaptureBtn = document.getElementById('desktop-capture');
			webcam.width = cont.clientWidth;
			canvas.width = webcam.width;
			canvas.height = webcam.width;

			let saveFiles = false;
			if (window.File && window.FileReader && window.FileList && window.Blob) {
				saveFiles = true;
				console.log("%c Save file enabled ", "color:lightgreen;background:black;");
			}

			navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
			if (navigator.getUserMedia) { 
				navigator.getUserMedia({video: true}, videoHandler, videoError);
			}
			function videoHandler(stream) {
				console.log(stream);
				webcam.src = window.URL.createObjectURL(stream);
			}
			function videoError(error) {
				console.log(error);
			}

			function mirrorImage() {
				context.save();
				context.translate(canvas.width, 0);
				context.scale(-1,1); // flip the image on the x-axis
				context.drawImage(webcam, 0, 0, canvas.width, canvas.height);
				context.restore();
			}
			let photoInterval;
			function startCameraInterval() {
				photoInterval = setInterval(mirrorImage, 1000 / 24);
			}
			webcam.addEventListener("loadedmetadata", startCameraInterval);

			function capture() {
				const img = new Image();
				img.onload = drawImage;
				img.src = skels[Math.floor(Math.random() * skels.length)];
				clearInterval(photoInterval);
				mirrorImage();
				function drawImage() {
					context.drawImage(img, 0, 0, canvas.width, canvas.height);
					if (saveFiles) {
						canvas.toBlob(function(blob) {
							saveAs(blob, "photo.png");
						});
					} else {
						const cap = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
						window.location.href = cap;
					}
				}
			}
			desktopCaptureBtn.addEventListener('click', capture);
		}
		
		window.addEventListener('load', init);


	</script>
</body>